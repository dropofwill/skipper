<!DOCTYPE html>
<html>
	<head>
		<link rel="stylesheet" href="$views/css/image.css">
		<link rel="stylesheet" href="$views/css/list.css">
		<link rel="stylesheet" href="$views/css/buttons.css">
		<link rel="stylesheet" href="css/main.css">
		<link rel="stylesheet" href="css/github.css">
		<script src="js/jq.js"></script>
	</head>
	<body>
		<div id="wrapper">
			<div id="index" class="section">
			<h1>Skipper</h1>
			

			<div id="html"></div>
			
			<form>
				<input type="radio" name="shuffle" value="shuffled" checked="checked"> Play Shuffled &nbsp;&nbsp;
				<input type="radio" name="shuffle" value="ordered"> Play in Order
			</form>

			<br>

			<div class="html-snippet" data-container="html">
				<div id="currently-playing"></div>
			</div>

			<div class="html-snippet" data-container="html">
				<div id="drop-box">Drag and drop a playlist here</div>
			</div>

			<div class="html-snippet" data-container="html">
				<div id="playlist-player"></div>
				<span id="timer"></span>
			</div>

			<script type="script/snippet" data-container="js">
				require(['$api/models', '$views/list#List'], function(models, List) {

					var a_counter = 0,
						current_duration;

					// Handle drops
					var dropBox = document.querySelector('#drop-box');
					var nowPlaying = document.getElementById('currently-playing');
					var positionTimer = document.getElementById('timer');

					function updateStatus(track) {
						if (track == null) {
							nowPlaying.innerHTML = "No track currently playing."
						} else {
							nowPlaying.innerHTML = "<b>" + track.name + " (" + track.duration/1000 + " sec.)</b> is currently playing";
						}
					}

					// update on load
					models.player.load('track').done(function(p) {
						updateStatus(p.track);
						current_duration = p.track.duration;
					});

					// update on change
					models.player.addEventListener('change', function(p) {
						updateStatus(p.data.track);
						current_duration = p.data.track.duration;
					});

					dropBox.addEventListener('dragstart', function(e){
						e.dataTransfer.setData('text/html', this.innerHTML);
						e.dataTransfer.effectAllowed = 'copy';
					}, false);

					dropBox.addEventListener('dragenter', function(e){
						e.preventDefault();
						e.dataTransfer.dropEffect = 'copy';
						this.classList.add('over');
					}, false);

					dropBox.addEventListener('dragover', function(e){
						e.preventDefault();
						e.dataTransfer.dropEffect = 'copy';
						return false;
					}, false);

					dropBox.addEventListener('dragleave', function(e){
						e.preventDefault();
						this.classList.remove('over');
					}, false);

					dropBox.addEventListener('drop', function(e){
						e.preventDefault();
						
						a_counter+=1;
						$('#playlist-player div').not("[data-connected-lists-index=a_counter]").addClass("hide");
						
						var drop = models.Playlist.fromURI(e.dataTransfer.getData('text'));

						this.classList.remove('over');
						
						var successMessage = document.createElement('p');
						successMessage.innerHTML = 'Playlist successfully dropped: ' + drop.uri;
						this.appendChild(successMessage);


						drop.load('tracks').done(function(tracks) {
							
							// Stuff purely for display purpoeses
							// Using snapshots for playing the song
						
							
							var a_list = List.forPlaylist(drop);
							document.getElementById('playlist-player').appendChild(a_list.node);
							a_list.init();

							// SetTimeout is a non-blocking function, so when executed in a loop it isn't paused
							// âˆ´ the loop structure is implemented with a recursive function songLoop which takes
							// the delay as an argument and calls itself until the tracks run out.
							

							drop.tracks.snapshot()
								.done(
									function( snapshot ) {
										var first_track, current_track, range_order;
										range_order = range( 0, snapshot.length-1, 1 );

										if ( toShuffle() == true ) {
											range_order = shuffleArray( range_order );
										}

										current_track = range_order[ 0 ];
										first_track = snapshot.get( current_track );

										playSong( first_track );

										songLoop( first_track.duration - 3000, current_track, range_order, snapshot );
									}
								);
						});
					}, false);
					
					
					function songLoop( duration, current_track, range_order, snapshot ) {
						setTimeout( function () {
							current_track++;

							if ( current_track < range_order.length ) {
								var next_track = snapshot.get( range_order[ current_track ] );
								
								playSong( next_track );

								songLoop( next_track.duration - 3000, current_track, range_order );
							}
						}, duration );
					}

					function playSong( a_track ) {
						models.player.playTrack(a_track);
					}

					// Fisher-Yates shuffle 
					function shuffleArray( an_array ) {
						var current_index = an_array.length;
						var random_index;
						var temp_value;

						while ( 0 !== current_index ) {
							random_index = Math.floor( Math.random() * current_index );
							current_index -= 1;

							temp_value = an_array[ current_index ];
							an_array[ current_index ] = an_array[ random_index ];
							an_array[ random_index ] = temp_value;
						}

						return an_array;
					}

					function toShuffle () {
						$checked = $('input[name="shuffle"]:checked').val();

						if ( $checked == 'ordered' ) {
							return false;
						}
						return true;
					}

					var range = function(start, end, step) {
					    var range = [];
					    var typeofStart = typeof start;
					    var typeofEnd = typeof end;

					    if (step === 0) {
					        throw TypeError("Step cannot be zero.");
					    }

					    if (typeofStart == "undefined" || typeofEnd == "undefined") {
					        throw TypeError("Must pass start and end arguments.");
					    } else if (typeofStart != typeofEnd) {
					        throw TypeError("Start and end arguments must be of same type.");
					    }

					    typeof step == "undefined" && (step = 1);

					    if (end < start) {
					        step = -step;
					    }

					    if (typeofStart == "number") {

					        while (step > 0 ? end >= start : end <= start) {
					            range.push(start);
					            start += step;
					        }

					    } else if (typeofStart == "string") {

					        if (start.length != 1 || end.length != 1) {
					            throw TypeError("Only strings with one character are supported.");
					        }

					        start = start.charCodeAt(0);
					        end = end.charCodeAt(0);

					        while (step > 0 ? end >= start : end <= start) {
					            range.push(String.fromCharCode(start));
					            start += step;
					        }

					    } else {
					        throw TypeError("Only string and number types are supported");
					    }

					    return range;

					}

				});
			</script>


			</div>
		</div>
		<script src="/js/rainbow-custom.min.js"></script>
		<script src="/js/tutorial.js"></script>
	</body>
</html>
